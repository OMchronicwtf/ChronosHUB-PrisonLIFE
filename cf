local Players           = game:GetService("Players")
local RunService        = game:GetService("RunService")
local UserInputService  = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace         = workspace

local LocalPlayer = Players.LocalPlayer
local Camera      = Workspace.CurrentCamera

-- Track respawn time for 0.5s delay
LocalPlayer.CharacterAdded:Connect(function(character)
    character:SetAttribute("RespawnTime", tick())
end)

local WindUI = loadstring(game:HttpGet(
    "https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"
))()

WindUI:AddTheme({
    Name = "E-vil Royal",
    Accent = WindUI:Gradient({
        ["0"] = { Color = Color3.fromHex("#360273"), Transparency = 0 },
        ["100"] = { Color = Color3.fromHex("#042444"), Transparency = 0 },
    }, { Rotation = 45 }),
    Background = WindUI:Gradient({
        ["0"] = { Color = Color3.fromHex("#360273"), Transparency = 0 },
        ["100"] = { Color = Color3.fromHex("#042444"), Transparency = 0 },
    }, { Rotation = 45 }),
    Dialog = Color3.fromHex("#1a1a1d"),
    Outline = Color3.fromHex("#FFD700"),
    Text = Color3.fromHex("#FFFFFF"),
    Placeholder = Color3.fromHex("#c0a763"),
    Button = Color3.fromHex("#28135b"),
    Icon = Color3.fromHex("#FFD700")
})
WindUI:SetTheme("E-vil Royal")

local Window = WindUI:CreateWindow({
    Title = "ChronosHUB",
    Icon = "moon-star",
    Author = "by @wtfchronic",
    Folder = "ChronosHUB",
    Size = UDim2.fromOffset(580, 460),
    MinSize = Vector2.new(560, 350),
    MaxSize = Vector2.new(850, 560),
    Transparent = true,
    Theme = "E-vil Royal",
    Resizable = true,
    SideBarWidth = 200,
    BackgroundImageTransparency = 0.3,
    HideSearchBar = false,
    ScrollBarEnabled = true,
    User = {
        Enabled = true,
        Anonymous = false,
        Callback = function() print("Have a wonderful day <3") end,
    },
})

Window:EditOpenButton({
    Title = "ChronosHUB",
    Icon = "moon",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("#574094"), Color3.fromHex("#FFD700")),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})

Window:DisableTopbarButtons({"Fullscreen"})
Window:Tag({Title = "v1.2.0", Color = Color3.fromHex("#FFD700"), Radius = 13})

local MainTab = Window:Tab({Title = "Main", Icon = "lucide:book-user", Locked = false})
local WeaponsSection = MainTab:Section({Title = "Weapons", Icon = "swords", Box = true, Opened = true})

-- Services
local Players       = game:GetService("Players")
local RunService    = game:GetService("RunService")
local Workspace     = workspace
local LocalPlayer   = Players.LocalPlayer

-- Character refs
local Character, RootPart, Humanoid
local lastSpawnTime = 0
LocalPlayer.CharacterAdded:Connect(function() lastSpawnTime = tick() end)

-- Target weapons
local targetWeapons = {"AK-47", "Remington 870", "M9"}
local AlreadyFound = {}  -- [name] = TouchTransmitter

-- === COOLDOWN SYSTEM ===
local lastUsed = 0
local COOLDOWN = 20  -- seconds

local function canUse()
    local timeLeft = COOLDOWN - (tick() - lastUsed)
    return timeLeft <= 0, timeLeft
end

local function startCooldown()
    lastUsed = tick()
end

-- === OPTIMIZED GUN LOGIC ===
local function FindTouchInterest(weaponName)
    if AlreadyFound[weaponName] then return AlreadyFound[weaponName] end
    for _, obj in Workspace:GetDescendants() do
        if obj.Name == "TouchGiver" and obj:GetAttribute("ToolName") == weaponName then
            local part = obj:FindFirstChildWhichIsA("BasePart") or obj
            local ti = part:FindFirstChildWhichIsA("TouchTransmitter") or part:FindFirstChildWhichIsA("TouchInterest")
            if ti then
                AlreadyFound[weaponName] = ti
                return ti
            end
        end
    end
end

local function hasWeapon(name)
    local bp = LocalPlayer.Backpack
    local ch = LocalPlayer.Character
    return (bp and bp:FindFirstChild(name)) or (ch and ch:FindFirstChild(name))
end

-- FAST collect: only for missing guns, one attempt
local function collectMissingGuns(missingList)
    if #missingList == 0 then return end

    local character = LocalPlayer.Character
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    for _, weaponName in ipairs(missingList) do
        if hasWeapon(weaponName) then continue end

        local ti = FindTouchInterest(weaponName)
        if ti then
            pcall(function()
                firetouchinterest(hrp, ti.Parent, 1)  -- untouch
                task.wait(0.45)
                firetouchinterest(hrp, ti.Parent, 0)  -- touch
            end)
            task.wait(0.25)
        end
    end
end

-- Smooth teleport (0.15s settle)
local function smoothTeleport(pos)
    if not RootPart or not Humanoid then return end
    Humanoid:ChangeState(Enum.HumanoidStateType.Physics)
    RootPart.CFrame = CFrame.new(pos)
    task.wait(0.15)
    Humanoid:ChangeState(Enum.HumanoidStateType.Running)
end

-- Teleport positions
local M9_REM_POS = Vector3.new(817.02, 100.56, 2217.40)
local AK47_POS   = Vector3.new(-922.74, 94.13, 2048.56)

-- === SELF-GRAB BUTTON (WITH 15s COOLDOWN) ===
WeaponsSection:Button({
    Title = "Self-Grab Guns",
    Justify = "Center",
    IconAlign = "right",
    Icon = "hand-grab",
    Callback = function()
        -- === COOLDOWN CHECK ===
        local can, timeLeft = canUse()
        if not can then
            WindUI:Notify({
                Title = "Self-Grab",
                Content = string.format("Wait %.1fs!", timeLeft),
                Duration = 1.5,
                Icon = "lucide:clock"
            }, true)
            return
        end

        -- Safety
        if LocalPlayer.Team and LocalPlayer.Team.Name == "Neutral" then
            WindUI:Notify({Title="Self-Grab",Content="Neutral ï¿¯ï¾¿ï¾¯ï¿¯ï¾¾ï¾¿ï¿¯ï¾¾ï¾¯ï¿¯ï¾¿ï¾¯ï¿¯ï¾¾ï¾¾ï¿¯ï¾¾ï¾¿ï¿¯ï¾¿ï¾¯ï¿¯ï¾¾ï¾¾ï¿¯ï¾¾ï¾¢ï¿¯ï¾¿ï¾¯ï¿¯ï¾¾ï¾¿ï¿¯ï¾¾ï¾¯ï¿¯ï¾¿ï¾¯ï¿¯ï¾¾ï¾¾ï¿¯ï¾¾ï¾¾ï¿¯ï¾¿ï¾¯ï¿¯ï¾¾ï¾¾ï¿¯ï¾¾ï¾€ï¿¯ï¾¿ï¾¯ï¿¯ï¾¾ï¾¿ï¿¯ï¾¾ï¾¯ï¿¯ï¾¿ï¾¯ï¿¯ï¾¾ï¾¾ï¿¯ï¾¾ï¾¾ï¿¯ï¾¿ï¾¯ï¿¯ï¾¾ï¾¾ï¿¯ï¾¾ï¾“ no grab!",Duration=2,Icon="lucide:circle-x"},true)
            return
        end

        Character = LocalPlayer.Character
        if not Character then return end

        RootPart = Character:FindFirstChild("HumanoidRootPart")
        Humanoid = Character:FindFirstChildOfClass("Humanoid")
        if not RootPart or not Humanoid or Humanoid.Health <= 0 then
            WindUI:Notify({Title="Self-Grab",Content="Cannot grab now...",Duration=2,Icon="lucide:circle-x"},true)
            return
        end

        if tick() - lastSpawnTime < 0.25 then
            WindUI:Notify({Title="Self-Grab",Content="Wait 0.25s after spawn!",Duration=2,Icon="lucide:clock"},true)
            return
        end

        -- === FIND MISSING GUNS ===
        local missing = {}
        for _, name in ipairs(targetWeapons) do
            if not hasWeapon(name) then table.insert(missing, name) end
        end

        if #missing == 0 then
            WindUI:Notify({Title="Self-Grab",Content="Already collected Guns!",Duration=2,Icon="lucide:info"},true)
            return
        end

        -- === START COOLDOWN + NOTIFY ===
        startCooldown()
        WindUI:Notify({Title="Self-Grab",Content="Collecting "..#missing.." gun(s)...",Duration=1.5,Icon="lucide:zap"},true)

        local startPos = RootPart.Position

        -- === GROUP BY LOCATION ===
        local needsM9Rem = false
        local needsAK = false
        local m9remGuns = {}

        for _, gun in ipairs(missing) do
            if gun == "AK-47" then
                needsAK = true
            else
                needsM9Rem = true
                table.insert(m9remGuns, gun)
            end
        end

        -- 1. M9 + Remington (if needed)
        if needsM9Rem then
            smoothTeleport(M9_REM_POS)
            collectMissingGuns(m9remGuns)
        end

        -- 2. AK-47 (if needed)
        if needsAK then
            smoothTeleport(AK47_POS)
            collectMissingGuns({"AK-47"})
        end

        -- 3. Return
        RootPart.CFrame = CFrame.new(startPos)

        task.delay(0.5, function()
            WindUI:Notify({Title="Self-Grab",Content="Guns collected!",Duration=2,Icon="lucide:hand-grab"},true)
        end)
    end
})

WeaponsSection:Divider()

local rapidFireEnabled = false
local infiniteRangeEnabled = false
local infiniteAmmoEnabled = false
local hookInitialized = false
local hookSetup = false
local originalNamecall
local rapidFireMode = nil
local RapidFireToggle = nil

local function setupAttributeHook()
    if hookSetup then return end
    hookSetup = true
    originalNamecall = hookmetamethod(game, "__namecall", function(self, ...)
        local method = getnamecallmethod()
        if not checkcaller() and method == "GetAttributes" then
            local result = originalNamecall(self, ...)
            if typeof(result) == "table" then
                if rapidFireEnabled then
                    result.AutoFire = true
                    result.FireRate = (rapidFireMode == "Fast") and 0.05 or 0
                end
                if infiniteRangeEnabled then
                    result.Range = 999999999999999
                    result.Spread = 10
                end
                if infiniteAmmoEnabled then
                    result.MaxAmmo = math.huge
                    result.CurrentAmmo = math.huge
                end
            end
            return result
        end
        return originalNamecall(self, ...)
    end)
end

local rapidFireInitialized = false
local wasCanceled = false

local function ShowRapidFireDialog()
    wasCanceled = false
    local Dialog = Window:Dialog({
        Title = "Rapid Fire Mode",
        Content = "Choose your firing speed:",
        Buttons = {
            {
                Title = "Fast (0.05s)",
                Variant = "Tertiary",
                Callback = function()
                    rapidFireMode = "Fast"
                    rapidFireEnabled = true
                    if not hookInitialized then hookInitialized = true setupAttributeHook() end
                    WindUI:Notify({
                        Title = "Rapid Fire",
                        Content = "Fast Mode Enabled\n(Re-equip weapon)",
                        Duration = 3,
                        Icon = "lucide:squirrel"
                    }, true)
                end
            },
            {
                Title = "Instant (0s)",
                Variant = "Tertiary",
                Callback = function()
                    rapidFireMode = "Instant"
                    rapidFireEnabled = true
                    if not hookInitialized then hookInitialized = true setupAttributeHook() end
                    WindUI:Notify({
                        Title = "Rapid Fire",
                        Content = "Instant Mode Enabled\n(Re-equip weapon)",
                        Duration = 3,
                        Icon = "lucide:rabbit"
                    }, true)
                end
            },
            {
                Title = "Cancel",
                Variant = "Primary",
                Callback = function()
                    wasCanceled = true
                    task.spawn(function()
                        task.wait()
                        if RapidFireToggle then
                            RapidFireToggle:Set(false)
                        end
                    end)
                end
            }
        }
    })
    Dialog:Show()
end

RapidFireToggle = WeaponsSection:Toggle({
    Title = "Rapid Fire",
    Desc = "Increases your firerate & enables autofire.",
    Icon = "lucide:circle-check",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        if not rapidFireInitialized then
            rapidFireInitialized = true
            return
        end

        if state then
            ShowRapidFireDialog()
        else
            if not wasCanceled then
                rapidFireEnabled = false
                rapidFireMode = nil
                WindUI:Notify({
                    Title = "Rapid Fire",
                    Content = "Disabled (Re-equip weapon)",
                    Duration = 2,
                    Icon = "lucide:circle-x"
                }, true)
            else
                rapidFireEnabled = false
                rapidFireMode = nil
            end
        end
    end
})

local infiniteRangeInitialized = false
WeaponsSection:Toggle({
    Title = "Infinite Range",
    Desc = "Increases the weapon range & tweaks spread.",
    Icon = "lucide:circle-check",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        if not infiniteRangeInitialized then infiniteRangeInitialized = true return end
        if not hookInitialized then hookInitialized = true setupAttributeHook() end
        infiniteRangeEnabled = state
        WindUI:Notify({
            Title = "Infinite Range",
            Content = state and "Enabled (Re-equip weapon)" or "Disabled (Re-equip weapon)",
            Duration = 2,
            Icon = state and "lucide:land-plot" or "lucide:circle-x"
        }, true)
    end
})

local infiniteAmmoInitialized = false
WeaponsSection:Toggle({
    Title = "Infinite Ammo",
    Desc = "Never run out of ammunition.",
    Icon = "lucide:circle-check",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        if not infiniteAmmoInitialized then infiniteAmmoInitialized = true return end
        if not hookInitialized then hookInitialized = true setupAttributeHook() end
        infiniteAmmoEnabled = state
        WindUI:Notify({
            Title = "Infinite Ammo",
            Content = state and "Enabled (Re-equip weapon)" or "Disabled (Re-equip weapon)",
            Duration = 2,
            Icon = state and "lucide:infinity" or "lucide:circle-x"
        }, true)
    end
})

local PlayerTab = Window:Tab({Title = "Players", Icon = "lucide:users", Locked = false})

local KillfeedSection = PlayerTab:Section({Title = "Killfeed", Icon = "lucide:skull", Box = true, Opened = false})
local KillfeedFolder = ReplicatedStorage:WaitForChild("Killfeed")
local MAX_KILLS = 5
local killLines = {}

local KillfeedParagraph = KillfeedSection:Paragraph({
    Title = "Last 5 kills:",
    Desc = "No recent kills.",
    Locked = false,
})

task.spawn(function()
    task.wait(0.1)
    local desc = KillfeedParagraph.Instance:FindFirstChild("Desc", true)
    if desc and desc:IsA("TextLabel") then
        desc.TextSize = 12
        desc.TextYAlignment = Enum.TextYAlignment.Top
    end
end)

local function cleanName(name)
    return name:gsub("%s*%(@.-%)", "")
end

local function updateKillfeed()
    KillfeedParagraph:SetDesc(#killLines == 0 and "No recent kills." or table.concat(killLines, "\n\n"))
end

local function addKill(entry)
    if not entry:IsA("IntValue") then return end
    local killer, victim, weapon = entry.Name:match("^(.+) killed (.+) with (.+)$")
    if not killer then return end
    killer = cleanName(killer)
    table.insert(killLines, 1, killer .. "killed " .. victim .. " with " .. weapon)
    if #killLines > MAX_KILLS then table.remove(killLines) end
    updateKillfeed()
end

for _, child in ipairs(KillfeedFolder:GetChildren()) do addKill(child) end
KillfeedFolder.ChildAdded:Connect(addKill)

local PlayerSection = PlayerTab:Section({Title = "Self", Icon = "lucide:user", Box = true, Opened = true})

local lastDeathPosition
local deathPointEnabled = false
local deathPointConn
local deathPointInitialized = false

PlayerSection:Toggle({
    Title = "Spawn at DeathPoint",
    Desc = "Respawn where you died.",
    Icon = "lucide:circle-check",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        if not deathPointInitialized then deathPointInitialized = true return end
        deathPointEnabled = state

        local function setupDied(char)
            local hum = char:WaitForChild("Humanoid")
            hum.Died:Connect(function()
                if deathPointEnabled then
                    local root = char:FindFirstChild("HumanoidRootPart")
                    if root then lastDeathPosition = root.Position end
                end
            end)
        end

        local function handleCharAdded(newChar)
            setupDied(newChar)
            if deathPointEnabled and lastDeathPosition then
                task.wait(0.1)
                local root = newChar:FindFirstChild("HumanoidRootPart")
                if root then root.CFrame = CFrame.new(lastDeathPosition) end
            end
        end

        if state then
            WindUI:Notify({Title="DeathPoint",Content="Enabled",Duration=2,Icon="lucide:map-pin"},true)
            local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            setupDied(char)
            deathPointConn = LocalPlayer.CharacterAdded:Connect(handleCharAdded)
        else
            WindUI:Notify({Title="DeathPoint",Content="Disabled",Duration=2,Icon="lucide:map-pin-off"},true)
            if deathPointConn then deathPointConn:Disconnect() deathPointConn = nil end
        end
    end
})

local infiniteStaminaEnabled = false
local staminaConn
local staminaInitialized = false

PlayerSection:Toggle({
    Title = "No Jump Delay",
    Desc = "Removes the short delay between jumps. Disabling will reset character.",
    Icon = "lucide:circle-check",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        if not staminaInitialized then staminaInitialized = true return end
        infiniteStaminaEnabled = state

        local function DisconnectStamina(Humanoid)
            task.wait(1)
            for _, conn in ipairs(getconnections(Humanoid.Jumping)) do conn:Disconnect() end
        end

        local function HandleChar(Character)
            local Humanoid = Character:WaitForChild("Humanoid", 10)
            if Humanoid then DisconnectStamina(Humanoid) end
        end

        if state then
            WindUI:Notify({Title="No Jump Delay",Content="Enabled",Duration=2,Icon="lucide:zap"},true)
            local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            HandleChar(Character)
            staminaConn = LocalPlayer.CharacterAdded:Connect(function(Char)
                if infiniteStaminaEnabled then HandleChar(Char) end
            end)
        else
            WindUI:Notify({Title="No Jump Delay",Content="Disabled",Duration=2,Icon="lucide:zap-off"},true)
            if staminaConn then staminaConn:Disconnect() staminaConn = nil end
            local Character = LocalPlayer.Character
            if Character then Character:BreakJoints() task.wait(1.5) end
        end
    end
})

local autoOpenDoorsEnabled = false
local autoOpenConn = nil
local autoOpenInitialized = false

local touchInterestParts = {}
local touchInterestConnections = {}

local Doors = Workspace:WaitForChild("Doors", 10)
local gateButton = Workspace:WaitForChild("Prison_ITEMS", 10)
    and Workspace.Prison_ITEMS:WaitForChild("buttons", 10)
    and Workspace.Prison_ITEMS.buttons:WaitForChild("Prison Gate", 10)
    and Workspace.Prison_ITEMS.buttons["Prison Gate"]:WaitForChild("Prison Gate", 10)

local gateRemote = Workspace:FindFirstChild("Remote") and Workspace.Remote:FindFirstChild("ItemHandler")

local function updateTouchInterestParts()
    if not Doors then return end

    for part, conn in pairs(touchInterestConnections) do
        if conn.Connected then conn:Disconnect() end
    end
    touchInterestConnections = {}
    table.clear(touchInterestParts)

    for _, obj in ipairs(Doors:GetDescendants()) do
        if obj:IsA("TouchTransmitter") then
            local part = obj.Parent
            if part and part:IsA("BasePart") then
                if not table.find(touchInterestParts, part) then
                    table.insert(touchInterestParts, part)
                end

                if not touchInterestConnections[part] then
                    touchInterestConnections[part] = part.AncestryChanged:Connect(function()
                        if not part:IsDescendantOf(Workspace) then
                            local index = table.find(touchInterestParts, part)
                            if index then table.remove(touchInterestParts, index) end
                            if touchInterestConnections[part] then
                                touchInterestConnections[part]:Disconnect()
                                touchInterestConnections[part] = nil
                            end
                        end
                    end)
                end
            end
        end
    end
end

if Doors then
    updateTouchInterestParts()

    local descendantAddedConn = Doors.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("TouchTransmitter") then
            task.wait()
            updateTouchInterestParts()
        end
    end)

    local descendantRemovingConn = Doors.DescendantRemoving:Connect(function(descendant)
        if descendant:IsA("TouchTransmitter") then
            task.defer(updateTouchInterestParts)
        end
    end)
end

PlayerSection:Toggle({
    Title = "Auto-Open Doors",
    Desc = "Auto-opens all doors if you're a Guard or holding a keycard. Also opens the main gate when nearby.",
    Icon = "lucide:circle-check",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        if not autoOpenInitialized then 
            autoOpenInitialized = true 
            return 
        end
        autoOpenDoorsEnabled = state

        if state then
            WindUI:Notify({
                Title = "Auto-Open Doors",
                Content = "Enabled",
                Duration = 2,
                Icon = "lucide:door-open"
            }, true)

            updateTouchInterestParts()

            autoOpenConn = RunService.Heartbeat:Connect(function()
                if not autoOpenDoorsEnabled then return end

                local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
                if playerGui then
                    local home = playerGui:FindFirstChild("Home")
                    if home then
                        local fadeFrame = home:FindFirstChild("fadeFrame")
                        if fadeFrame and fadeFrame.BackgroundTransparency ~= 1 then
                            return
                        end
                    end
                end

                if LocalPlayer.Team and LocalPlayer.Team.Name == "Neutral" then return end

                local Character = LocalPlayer.Character
                if not Character or not Character:FindFirstChildOfClass("Humanoid") then return end
                if Character:FindFirstChildOfClass("Humanoid").Health <= 0 then return end
                if tick() - (Character:GetAttribute("RespawnTime") or 0) < 0.5 then return end

                local openPart = Character:FindFirstChild("Right Arm") or Character:FindFirstChildWhichIsA("BasePart")
                if not openPart then return end

                for _, part in ipairs(touchInterestParts) do
                    if part and part.Parent and openPart.Parent then
                        task.spawn(function()
                            firetouchinterest(openPart, part, 0)
                            task.wait()
                            firetouchinterest(openPart, part, 1)
                        end)
                    end
                end

                if gateButton and gateButton:FindFirstChild("isActive") and gateButton.isActive.Value == false then
                    local args = { gateButton }
                    pcall(function()
                        if gateRemote then
                            gateRemote:InvokeServer(unpack(args))
                        end
                    end)
                end
            end)

        else
            WindUI:Notify({
                Title = "Auto-Open Doors",
                Content = "Disabled",
                Duration = 2,
                Icon = "lucide:door-closed"
            }, true)

            if autoOpenConn then
                autoOpenConn:Disconnect()
                autoOpenConn = nil
            end
        end
    end
})

local noclipEnabled = false
local noclipConn
local noclipInitialized = false
local floatName = "HumanoidRootPart"

local function enableNoclipForChar(char)
    if not char then return end
    local function noclipLoop()
        if noclipEnabled and char then
            for _, part in pairs(char:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide and part.Name ~= floatName then
                    part.CanCollide = false
                end
            end
        end
    end
    noclipConn = RunService.Stepped:Connect(noclipLoop)
end

local function disableNoclip()
    if noclipConn then noclipConn:Disconnect() noclipConn = nil end
    local char = LocalPlayer.Character
    if char then
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= floatName then
                part.CanCollide = true
            end
        end
    end
end

PlayerSection:Toggle({
    Title = "Noclip",
    Desc = "Pass through walls.",
    Icon = "lucide:circle-check",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        if not noclipInitialized then noclipInitialized = true return end
        noclipEnabled = state

        if state then
            WindUI:Notify({Title="Noclip",Content="Enabled",Duration=2,Icon="lucide:ghost"},true)
            local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            enableNoclipForChar(char)
            LocalPlayer.CharacterAdded:Connect(function(newChar)
                if noclipEnabled then task.wait(0.1) enableNoclipForChar(newChar) end
            end)
        else
            WindUI:Notify({Title="Noclip",Content="Disabled",Duration=2,Icon="lucide:circle-x"},true)
            disableNoclip()
        end
    end
})

local autoSnacksEnabled = false
local autoSnacksConn = nil
local autoSnacksInitialized = false

local snackHandles = {}
local folderConnections = {}

local function clearSnackHandles()
    table.clear(snackHandles)
end

local function addSnackHandle(part)
    if not snackHandles[part] then
        snackHandles[part] = true
    end
end

local function removeSnackHandle(part)
    snackHandles[part] = nil
end

local function watchItemsFolder(folder)
    if folderConnections[folder] then return end

    local function onChildAdded(child)
        if child:IsA("Tool") then
            local handle = child:FindFirstChild("Handle") or child:FindFirstChildWhichIsA("BasePart")
            if handle then addSnackHandle(handle) end
        end
    end
    local function onChildRemoved(child)
        if child:IsA("Tool") then
            local handle = child:FindFirstChild("Handle") or child:FindFirstChildWhichIsA("BasePart")
            if handle then removeSnackHandle(handle) end
        end
    end

    for _, tool in ipairs(folder:GetChildren()) do
        onChildAdded(tool)
    end

    local added = folder.ChildAdded:Connect(onChildAdded)
    local removed = folder.ChildRemoved:Connect(onChildRemoved)

    folderConnections[folder] = {added, removed}
end

local function unwatchItemsFolder(folder)
    local conns = folderConnections[folder]
    if conns then
        conns[1]:Disconnect()
        conns[2]:Disconnect()
        folderConnections[folder] = nil
    end
end

local function refreshVendingMachines()
    clearSnackHandles()
    for _, folder in pairs(folderConnections) do
        unwatchItemsFolder(folder[1])
    end

    for _, model in ipairs(Workspace:GetDescendants()) do
        if model:IsA("Model") and model.Name == "vending machine" then
            local items = model:FindFirstChild("Items") or model:FindFirstChild("items")
            if items then
                watchItemsFolder(items)
            end
        end
    end
end

local vmAdded, vmRemoved
vmAdded = Workspace.DescendantAdded:Connect(function(desc)
    if desc:IsA("Model") and desc.Name == "vending machine" then
        task.wait()
        refreshVendingMachines()
    end
end)
vmRemoved = Workspace.DescendantRemoving:Connect(function(desc)
    if desc:IsA("Model") and desc.Name == "vending machine" then
        refreshVendingMachines()
    end
end)

refreshVendingMachines()

PlayerSection:Toggle({
    Title = "Auto-Grab Snacks",
    Desc = "Automatically collects snacks from both vending machines.",
    Icon = "lucide:circle-check",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        if not autoSnacksInitialized then
            autoSnacksInitialized = true
            return
        end
        autoSnacksEnabled = state

        if state then
            WindUI:Notify({
                Title = "Auto-Grab Snacks",
                Content = "Enabled",
                Duration = 2,
                Icon = "lucide:candy"
            }, true)

            autoSnacksConn = RunService.Heartbeat:Connect(function()
                if not autoSnacksEnabled then return end

                local char = LocalPlayer.Character
                if not char then return end

                local touchPart = char:FindFirstChild("Right Arm") or char:FindFirstChildWhichIsA("BasePart")
                if not touchPart then return end

                local anySnack = false
                for part in pairs(snackHandles) do
                    anySnack = true
                    break
                end
                if not anySnack then return end

                for part in pairs(snackHandles) do
                    if part and part.Parent and touchPart.Parent then
                        task.spawn(function()
                            firetouchinterest(touchPart, part, 0)
                            task.wait()
                            firetouchinterest(touchPart, part, 1)
                        end)
                    end
                end
            end)

        else
            WindUI:Notify({
                Title = "Auto-Grab Snacks",
                Content = "Disabled",
                Duration = 2,
                Icon = "lucide:candy-off"
            }, true)

            if autoSnacksConn then
                autoSnacksConn:Disconnect()
                autoSnacksConn = nil
            end
        end
    end
})

local AimbotTab = Window:Tab({Title = "Aimbot & ESP", Icon = "lucide:target", Locked = false})
local AimbotSection = AimbotTab:Section({Title = "Aimbot", Icon = "lucide:crosshair", Box = true, Opened = false})

local aimbotEnabled = false
local aimbotActive = false
local aimbotFeatures = {TeamCheck = true, VisibleCheck = true, Prediction = true, Smoothing = true, FOVCircle = false}
local aimPart = "Head"
local circleRadius = 120
local sensitivity = 0.25
local smoothSetting = 0.2
local predictionFactor = 0.1

local AimbotInitialized = false
local aimbotDropdownInitialized = false
local FOVCircle

local function UpdateFOVCircle()
    if not FOVCircle then return end
    FOVCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    FOVCircle.Visible = aimbotEnabled and aimbotFeatures.FOVCircle
end

local function isVisible(targetPart)
    if not targetPart then return false end
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin).Unit * 500
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character or {}, Camera}
    params.IgnoreWater = true
    local result = Workspace:Raycast(origin, direction, params)
    return not result or (result.Instance and result.Instance:IsDescendantOf(targetPart.Parent))
end

local function resolveTargetPosition(target)
    if not target or not target:FindFirstChild(aimPart) then return nil end
    local targetPart = target:FindFirstChild(aimPart)
    local pos = targetPart.Position
    if aimbotFeatures.Prediction and targetPart.Velocity then
        pos = pos + (targetPart.Velocity * predictionFactor)
    end
    return pos
end

local function getClosestPlayerInFOV()
    local closest, bestDist = nil, circleRadius
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild(aimPart) then
            if aimbotFeatures.TeamCheck and LocalPlayer.Team and plr.Team and LocalPlayer.Team == plr.Team then continue end
            local part = plr.Character:FindFirstChild(aimPart)
            if aimbotFeatures.VisibleCheck and not isVisible(part) then continue end
            local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                if dist < bestDist then bestDist = dist closest = plr.Character end
            end
        end
    end
    return closest
end

local function trackTarget(target)
    if not target then return end
    local pos = resolveTargetPosition(target)
    if not pos then return end
    local targetCFrame = CFrame.new(Camera.CFrame.Position, pos)
    local lerpVal = aimbotFeatures.Smoothing and ((1 - smoothSetting) * sensitivity + smoothSetting * 0.1) or sensitivity
    Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, lerpVal)
end

local function InitializeAimbot()
    if AimbotInitialized then return end
    AimbotInitialized = true

    FOVCircle = Drawing.new("Circle")
    FOVCircle.Filled = false
    FOVCircle.Transparency = 0.7
    FOVCircle.NumSides = 64
    FOVCircle.Thickness = 2
    FOVCircle.Color = Color3.fromRGB(138, 43, 226)
    FOVCircle.Radius = circleRadius

    RunService.RenderStepped:Connect(UpdateFOVCircle)

    UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        if input.UserInputType == Enum.UserInputType.MouseButton2 and aimbotEnabled then
            aimbotActive = true
        end
    end)

    UserInputService.InputEnded:Connect(function(input, processed)
        if processed then return end
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            aimbotActive = false
        end
    end)

    RunService.RenderStepped:Connect(function()
        if aimbotActive and aimbotEnabled then
            local target = getClosestPlayerInFOV()
            if target then trackTarget(target) end
        end
    end)
end

local aimbotToggleInitialized = false
AimbotSection:Toggle({
    Title = "Enable Aimbot",
    Desc = "Aim-Lock onto players.",
    Icon = "lucide:circle-check",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        if not aimbotToggleInitialized then aimbotToggleInitialized = true return end
        InitializeAimbot()
        aimbotEnabled = state
        if FOVCircle then FOVCircle.Visible = state and aimbotFeatures.FOVCircle end
        WindUI:Notify({
            Title = "Aimbot",
            Content = state and "Enabled (Powered by REM)" or "Disabled",
            Duration = 2,
            Icon = state and "lucide:crosshair" or "lucide:circle-x"
        }, true)
    end
})

AimbotSection:Dropdown({
    Title = "Elements",
    Desc = "",
    Values = {"Team Check", "Visible Check", "Prediction", "Smoothing", "FOV Circle"},
    Value = {"Team Check", "Visible Check", "Prediction", "Smoothing"},
    Multi = true,
    AllowNone = false,
    Callback = function(selected)
        InitializeAimbot()
        if not aimbotDropdownInitialized then
            aimbotDropdownInitialized = true
            for _, v in ipairs(selected) do
                if v == "Team Check" then aimbotFeatures.TeamCheck = true
                elseif v == "Visible Check" then aimbotFeatures.VisibleCheck = true
                elseif v == "Prediction" then aimbotFeatures.Prediction = true
                elseif v == "Smoothing" then aimbotFeatures.Smoothing = true
                elseif v == "FOV Circle" then aimbotFeatures.FOVCircle = true
                end
            end
            if FOVCircle then FOVCircle.Visible = aimbotEnabled and aimbotFeatures.FOVCircle end
            return
        end

        for k in pairs(aimbotFeatures) do aimbotFeatures[k] = false end
        for _, v in ipairs(selected) do
            if v == "Team Check" then aimbotFeatures.TeamCheck = true
            elseif v == "Visible Check" then aimbotFeatures.VisibleCheck = true
            elseif v == "Prediction" then aimbotFeatures.Prediction = true
            elseif v == "Smoothing" then aimbotFeatures.Smoothing = true
            elseif v == "FOV Circle" then aimbotFeatures.FOVCircle = true
            end
        end
        if FOVCircle then FOVCircle.Visible = aimbotEnabled and aimbotFeatures.FOVCircle end
    end
})

AimbotSection:Divider()

AimbotSection:Slider({
    Title = "Smoothing",
    Desc = "Higher = Smoother",
    Value = { Min = 0, Max = 1, Default = smoothSetting },
    Step = 0.01,
    Callback = function(value) InitializeAimbot() smoothSetting = value end
})

AimbotSection:Slider({
    Title = "Prediction Strength",
    Desc = "Higher = Stronger",
    Value = { Min = 0, Max = 0.5, Default = predictionFactor },
    Step = 0.01,
    Callback = function(value) InitializeAimbot() predictionFactor = value end
})

local SilentSection = AimbotTab:Section({Title = "Mobile Aim", Icon = "lucide:zap", Box = true, Opened = false})

-- settings (now REAL aimbot)
local aimbotEnabled = false
local aimbotInitialized = false
local aimbotFeatures = { TeamCheck = true, VisibleCheck = true, Prediction = true, FOVCircle = true }
local aimbotAimPart = "Head" -- hardcoded
local aimbotFOVRadius = 120
local aimbotPredictionStrength = 0.12
local aimbotSmoothness = 0.15 -- NEW: camera smoothing for mobile

-- drawing objects
local FOVCircle = nil
local TargetSquare = nil
local PredictedMarker = nil

-- services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Workspace = workspace

-- target tracking
local currentTarget = nil
local originalCameraCFrame = nil

-- team check
local function IsValidTarget(plr)
    if plr == LocalPlayer then return false end
    if aimbotFeatures.TeamCheck and LocalPlayer.Team and plr.Team and LocalPlayer.Team == plr.Team then return false end
    return plr.Character and plr.Character:FindFirstChild(aimbotAimPart)
end

-- visibility check
local function IsVisible(part)
    if not part then return false end
    local origin = Camera.CFrame.Position
    local direction = (part.Position - origin).Unit * 500
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character or {}, Camera}
    params.IgnoreWater = true
    local result = Workspace:Raycast(origin, direction, params)
    return not result or result.Instance:IsDescendantOf(part.Parent)
end

-- predict position
local function GetPredictedPosition(char)
    local part = char:FindFirstChild(aimbotAimPart)
    if not part then return nil end
    
    local pos = part.Position
    if aimbotFeatures.Prediction and part.Velocity.Magnitude > 0 then
        pos = pos + (part.Velocity * aimbotPredictionStrength)
    end
    return pos
end

-- get closest target in FOV
local function GetClosestTarget()
    local closest, bestDist = nil, aimbotFOVRadius
    local mousePos = UserInputService:GetMouseLocation()
    
    for _, plr in ipairs(Players:GetPlayers()) do
        if IsValidTarget(plr) and aimbotFeatures.VisibleCheck == false or IsVisible(plr.Character:FindFirstChild(aimbotAimPart)) then
            local predictedPos = GetPredictedPosition(plr.Character)
            if predictedPos then
                local screenPos, onScreen = Camera:WorldToViewportPoint(predictedPos)
                if onScreen then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(mousePos.X, mousePos.Y)).Magnitude
                    if dist < bestDist then
                        bestDist = dist
                        closest = plr.Character
                    end
                end
            end
        end
    end
    
    return closest
end

-- smooth camera aim
local function AimAtTarget(targetChar)
    if not targetChar then 
        currentTarget = nil
        return 
    end
    
    local predictedPos = GetPredictedPosition(targetChar)
    if not predictedPos then return end
    
    local targetCFrame = CFrame.lookAt(Camera.CFrame.Position, predictedPos)
    
    -- smooth interpolation (mobile-friendly)
    Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, aimbotSmoothness)
    currentTarget = targetChar
end

-- main aimbot loop
local function UpdateAimbot()
    if not aimbotEnabled then 
        currentTarget = nil
        return 
    end
    
    local closestTarget = GetClosestTarget()
    AimAtTarget(closestTarget)
end

-- update visuals
local function UpdateVisuals()
    local mousePos = UserInputService:GetMouseLocation()
    
    -- FOV Circle
    if FOVCircle then
        FOVCircle.Radius = aimbotFOVRadius
        FOVCircle.Position = mousePos
        FOVCircle.Visible = aimbotEnabled and aimbotFeatures.FOVCircle
    end
    
    -- Target indicators
    if TargetSquare then TargetSquare.Visible = false end
    if PredictedMarker then PredictedMarker.Visible = false end
    
    if aimbotEnabled and currentTarget then
        local part = currentTarget:FindFirstChild(aimbotAimPart)
        if part then
            local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
            if onScreen then
                TargetSquare.Position = Vector2.new(screenPos.X - 8, screenPos.Y - 8)
                TargetSquare.Size = Vector2.new(16, 16)
                TargetSquare.Visible = true
                TargetSquare.Color = Color3.fromRGB(0, 255, 0) -- Green for locked
            end
            
            if aimbotFeatures.Prediction then
                local predPos = GetPredictedPosition(currentTarget)
                if predPos then
                    local predScreen, predOnScreen = Camera:WorldToViewportPoint(predPos)
                    if predOnScreen then
                        PredictedMarker.Position = Vector2.new(predScreen.X, predScreen.Y)
                        PredictedMarker.Visible = true
                    end
                end
            end
        end
    end
end

-- initialization
local function InitializeAimbot()
    if aimbotInitialized then return end
    aimbotInitialized = true
    
    -- FOV Circle
    FOVCircle = Drawing.new("Circle")
    FOVCircle.Filled = false
    FOVCircle.Transparency = 0.8
    FOVCircle.NumSides = 64
    FOVCircle.Thickness = 2
    FOVCircle.Color = Color3.fromRGB(255, 84, 0)
    FOVCircle.Radius = aimbotFOVRadius
    FOVCircle.Visible = false
    
    -- Target Square
    TargetSquare = Drawing.new("Square")
    TargetSquare.Filled = true
    TargetSquare.Size = Vector2.new(16, 16)
    TargetSquare.Thickness = 1
    TargetSquare.Color = Color3.fromRGB(0, 255, 0)
    TargetSquare.Visible = false
    TargetSquare.Transparency = 0.7
    
    -- Prediction Marker
    PredictedMarker = Drawing.new("Circle")
    PredictedMarker.Filled = true
    PredictedMarker.NumSides = 24
    PredictedMarker.Radius = 4
    PredictedMarker.Thickness = 1
    PredictedMarker.Color = Color3.fromRGB(255, 200, 0)
    PredictedMarker.Visible = false
    
    -- Connect loops
    RunService.Heartbeat:Connect(UpdateAimbot)  -- Aim loop (pre-render)
    RunService.RenderStepped:Connect(UpdateVisuals)  -- Visuals only
end

-- UI TOGGLE (MAIN AIMBOT)
SilentSection:Toggle({
    Title = "Mobile Aimbot",
    Desc = "Locks camera onto closest target in FOV (Mobile Optimized)",
    Icon = "lucide:zap",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        InitializeAimbot()
        aimbotEnabled = state
        
        if FOVCircle then 
            FOVCircle.Visible = state and aimbotFeatures.FOVCircle 
        end
        
        WindUI:Notify({
            Title = "Mobile Aimbot",
            Content = state and "ðŸ”’ Camera Lock Enabled" or "Camera Free",
            Duration = 2,
            Icon = state and "lucide:lock" or "lucide:unlock"
        }, true)
    end
})

-- Features Dropdown
SilentSection:Dropdown({
    Title = "Features",
    Desc = "",
    Values = {"Team Check", "Visible Check", "Prediction", "FOV Circle"},
    Value = {"Team Check", "Prediction", "FOV Circle"},
    Multi = true,
    AllowNone = false,
    Callback = function(selected)
        InitializeAimbot()
        for k in pairs(aimbotFeatures) do aimbotFeatures[k] = false end
        for _, v in ipairs(selected) do
            if v == "Team Check" then aimbotFeatures.TeamCheck = true
            elseif v == "Visible Check" then aimbotFeatures.VisibleCheck = true
            elseif v == "Prediction" then aimbotFeatures.Prediction = true
            elseif v == "FOV Circle" then aimbotFeatures.FOVCircle = true end
        end
    end
})

-- FOV Slider
SilentSection:Slider({
    Title = "FOV Radius",
    Desc = "Detection radius around touch/mouse",
    Value = { Min = 50, Max = 500, Default = aimbotFOVRadius },
    Step = 5,
    Callback = function(value)
        InitializeAimbot()
        aimbotFOVRadius = value
        if FOVCircle then FOVCircle.Radius = value end
    end
})

-- Prediction Slider
SilentSection:Slider({
    Title = "Prediction",
    Desc = "Lead moving targets",
    Value = { Min = 0, Max = 0.5, Default = aimbotPredictionStrength },
    Step = 0.01,
    Callback = function(value)
        aimbotPredictionStrength = value
    end
})

-- NEW: Smoothness Slider (Mobile Essential)
SilentSection:Slider({
    Title = "Smoothness",
    Desc = "0.1 = Snappy | 0.3 = Smooth (Mobile)",
    Value = { Min = 0.05, Max = 0.5, Default = aimbotSmoothness },
    Step = 0.01,
    Callback = function(value)
        aimbotSmoothness = value
    end
})

local ESPSection = AimbotTab:Section({Title = "ESP", Icon = "users", Box = true, Opened = false})

local Players      = game:GetService("Players")
local RunService   = game:GetService("RunService")
local Camera       = workspace.CurrentCamera
local LocalPlayer  = Players.LocalPlayer

local espEnabled   = false
local useBoxESP    = false

local espFeatures  = {
    Names      = true,
    HealthBars = true,
    Tracers    = false,
    Teammates  = false,
    Rainbow    = false
}

local espMasterInitialized = false
local espDropdownInitialized = false
local espNeedsFirstRefresh = true
local ESPObjs      = {}
local ESPHighlights = {}

local function HealthLerp(ratio)
    return Color3.fromRGB(math.floor(255 * (1 - ratio)), math.floor(255 * ratio), 0)
end

local function GetTeamColour(plr)
    return plr.TeamColor and plr.TeamColor.Color or Color3.fromRGB(255,255,255)
end

-- -------------------------------------------------
-- TEAM CHECK (used for both boxes & highlights)
-- -------------------------------------------------
local function ShouldShow(plr)
    if plr == LocalPlayer then return false end
    local teammate = LocalPlayer.Team and plr.Team and LocalPlayer.Team == plr.Team
    return not teammate or espFeatures.Teammates
end

-- -------------------------------------------------
-- HIGHLIGHT ESP
-- -------------------------------------------------
local function ApplyHighlight(plr)
    if not ShouldShow(plr) then return end
    if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then return end

    if ESPHighlights[plr] then ESPHighlights[plr]:Destroy() end

    local hl = Instance.new("Highlight")
    hl.Adornee = plr.Character
    hl.FillTransparency   = 0.5
    hl.OutlineTransparency = 0
    hl.OutlineColor       = Color3.fromRGB(255,255,255)
    hl.FillColor          = plr.TeamColor and plr.TeamColor.Color or Color3.fromRGB(180,180,180)
    hl.Parent = plr.Character
    ESPHighlights[plr] = hl
end

local function RemoveHighlight(plr)
    if ESPHighlights[plr] then
        ESPHighlights[plr]:Destroy()
        ESPHighlights[plr] = nil
    end
end

local function UpdateHighlightColor(plr)
    if ESPHighlights[plr] then
        local tc = plr.TeamColor
        ESPHighlights[plr].FillColor = tc and tc.Color or Color3.fromRGB(180,180,180)
    end
end

-- -------------------------------------------------
-- DRAWING ESP (BOXES + OTHER ELEMENTS)
-- -------------------------------------------------
local function CreateESP(plr)
    if ESPObjs[plr] or plr == LocalPlayer then return end

    local boxOut = Drawing.new("Square"); boxOut.Thickness = 3; boxOut.Filled = false; boxOut.Color = Color3.new()
    local boxIn  = Drawing.new("Square"); boxIn.Thickness  = 1; boxIn.Filled  = false
    local name   = Drawing.new("Text");   name.Size = 16; name.Center = true; name.Outline = true; name.Color = Color3.fromRGB(255,255,255)
    local hbMain = Drawing.new("Square"); hbMain.Filled = true
    local hbOut  = Drawing.new("Square"); hbOut.Thickness = 2; hbOut.Filled = false; hbOut.Color = Color3.new()
    local tracer = Drawing.new("Line");   tracer.Thickness = 1

    local drawings = {boxOut, boxIn, name, hbMain, hbOut, tracer}
    local conn

    local function Update()
        if not espEnabled or not plr.Character then
            for _,d in ipairs(drawings) do d.Visible = false end
            return
        end
        if not ShouldShow(plr) then
            for _,d in ipairs(drawings) do d.Visible = false end
            return
        end

        local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
        local head = plr.Character:FindFirstChild("Head")
        local hum  = plr.Character:FindFirstChild("Humanoid")
        if not (hrp and head and hum) then
            for _,d in ipairs(drawings) do d.Visible = false end
            return
        end

        local rootPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
        local headPos = Camera:WorldToViewportPoint(head.Position + Vector3.new(0,0.5,0))

        local teamCol    = GetTeamColour(plr)
        local rainbowHue = espFeatures.Rainbow and ((tick()%5)/5) or nil
        local finalCol   = rainbowHue and Color3.fromHSV(rainbowHue,1,1) or teamCol

        if onScreen then
            local height = math.abs(headPos.Y - rootPos.Y)
            local width  = height / 2

            -- BOXES
            if useBoxESP then
                boxOut.Size = Vector2.new(width, height)
                boxOut.Position = Vector2.new(rootPos.X - width/2, rootPos.Y - height/2)
                boxOut.Color = rainbowHue and Color3.fromHSV(rainbowHue,1,1) or Color3.new()
                boxOut.Visible = true

                boxIn.Size = boxOut.Size
                boxIn.Position = boxOut.Position
                boxIn.Color = finalCol
                boxIn.Visible = true
            else
                boxOut.Visible = false; boxIn.Visible = false
            end

            -- NAMES
            if espFeatures.Names then
                name.Text = plr.DisplayName .. " ["..math.floor(hum.Health).."/"..hum.MaxHealth.."]"
                name.Position = Vector2.new(rootPos.X, rootPos.Y - height/2 - 20)
                name.Visible = true
            else
                name.Visible = false
            end

            -- HEALTH BARS
            if espFeatures.HealthBars then
                local barW, barH = 5, height
                local ratio = hum.Health / hum.MaxHealth
                hbOut.Size = Vector2.new(barW, barH)
                hbOut.Position = Vector2.new(rootPos.X - width/2 - barW - 2, rootPos.Y - height/2)
                hbOut.Visible = true
                hbMain.Size = Vector2.new(barW, barH * ratio)
                hbMain.Position = Vector2.new(hbOut.Position.X, hbOut.Position.Y + barH*(1-ratio))
                hbMain.Color = HealthLerp(ratio)
                hbMain.Visible = true
            else
                hbMain.Visible = false; hbOut.Visible = false
            end

            -- TRACERS
            if espFeatures.Tracers then
                tracer.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
                tracer.To   = Vector2.new(rootPos.X, rootPos.Y)
                tracer.Color = rainbowHue and Color3.fromHSV(rainbowHue,1,1) or (LocalPlayer.Team and plr.Team and LocalPlayer.Team == plr.Team and Color3.fromRGB(0,255,0) or finalCol)
                tracer.Visible = true
            else
                tracer.Visible = false
            end
        else
            for _,d in ipairs(drawings) do d.Visible = false end
        end
    end

    conn = RunService.RenderStepped:Connect(Update)

    local function Cleanup()
        if conn then conn:Disconnect() end
        for _,d in ipairs(drawings) do pcall(d.Remove, d) end
    end

    ESPObjs[plr] = {conn = conn, cleanup = Cleanup, drawings = drawings}
end

local function RemoveESP(plr)
    if ESPObjs[plr] then ESPObjs[plr].cleanup() ESPObjs[plr] = nil end
end

-- -------------------------------------------------
-- REFRESH ALL
-- -------------------------------------------------
local function RefreshAll()
    if not espEnabled then return end
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then
            RemoveESP(p)
            RemoveHighlight(p)
            task.spawn(function()
                local char = p.Character or p.CharacterAdded:Wait()
                if char then
                    task.wait(0.1)
                    CreateESP(p)
                    if not useBoxESP and ShouldShow(p) then ApplyHighlight(p) end
                end
            end)
        end
    end
end

-- -------------------------------------------------
-- PLAYER JOIN / RESPAWN (FIXED: Highlights + Team check)
-- -------------------------------------------------
local function SetupPlayer(plr)
    if plr == LocalPlayer then return end

    plr:GetPropertyChangedSignal("TeamColor"):Connect(function()
        UpdateHighlightColor(plr)
    end)

    plr.CharacterAdded:Connect(function()
        task.wait(0.3)
        if espEnabled then
            CreateESP(plr)
            if not useBoxESP and ShouldShow(plr) then ApplyHighlight(plr) end
        end
    end)

    if plr.Character then
        task.delay(0.1, function()
            if espEnabled then
                CreateESP(plr)
                if not useBoxESP and ShouldShow(plr) then ApplyHighlight(plr) end
            end
        end)
    end
end

-- Hook existing players
for _, p in Players:GetPlayers() do
    SetupPlayer(p)
end

-- New players
Players.PlayerAdded:Connect(SetupPlayer)

-- Player leaving
Players.PlayerRemoving:Connect(function(p)
    RemoveESP(p)
    RemoveHighlight(p)
end)

-- -------------------------------------------------
-- MAIN ESP TOGGLE
-- -------------------------------------------------
ESPSection:Toggle({
    Title = "ESP",
    Desc = "View where players are located.",
    Icon = "lucide:circle-check",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        if not espMasterInitialized then
            espMasterInitialized = true
            if state then espEnabled = true RefreshAll() end
            return
        end
        espEnabled = state
        if state then
            WindUI:Notify({Title="ESP",Content="Enabled (Powered by REM)",Duration=2,Icon="lucide:eye"},true)
            RefreshAll()
        else
            WindUI:Notify({Title="ESP",Content="Disabled",Duration=2,Icon="lucide:eye-off"},true)
            for _,v in pairs(ESPObjs) do v.cleanup() end
            ESPObjs = {}
            for _,hl in pairs(ESPHighlights) do hl:Destroy() end
            ESPHighlights = {}
        end
    end
})

-- -------------------------------------------------
-- BOX ESP TOGGLE (ABOVE DROPDOWN)
-- -------------------------------------------------
local BoxTypeToggle -- declare first

BoxTypeToggle = ESPSection:Toggle({
    Title = "ESP Type",
    Desc = "Highlights",
    Icon = "lucide:square",
    Default = false, -- false = Highlights, true = Boxes
    Callback = function(state)
        useBoxESP = state

        -- Update description live
        if state then
            BoxTypeToggle:SetDesc("Boxes")
        else
            BoxTypeToggle:SetDesc("Highlights")
        end

        if espEnabled then
            RefreshAll()
        end
    end
})

-- -------------------------------------------------
-- ELEMENTS DROPDOWN
-- -------------------------------------------------
ESPSection:Dropdown({
    Title = "Elements",
    Desc = "",
    Values = {"None", "Names", "Health Bars", "Tracers", "Show Teammates", "Rainbow"},
    Value = {"Names", "Health Bars"},
    Multi = true,
    AllowNone = false,
    Callback = function(selected)
        if not espDropdownInitialized then
            espDropdownInitialized = true
            for _, v in ipairs(selected) do
                if v == "Names"      then espFeatures.Names      = true
                elseif v == "Health Bars" then espFeatures.HealthBars = true
                elseif v == "Tracers" then espFeatures.Tracers    = true
                elseif v == "Show Teammates" then espFeatures.Teammates  = true
                elseif v == "Rainbow" then espFeatures.Rainbow    = true
                end
            end
            if espEnabled and espNeedsFirstRefresh then
                espNeedsFirstRefresh = false
                RefreshAll()
            end
            return
        end

        for k in pairs(espFeatures) do espFeatures[k] = false end
        for _, v in ipairs(selected) do
            if v == "Names"      then espFeatures.Names      = true
            elseif v == "Health Bars" then espFeatures.HealthBars = true
            elseif v == "Tracers" then espFeatures.Tracers    = true
            elseif v == "Show Teammates" then espFeatures.Teammates  = true
            elseif v == "Rainbow" then espFeatures.Rainbow    = true
            end
        end
        if espEnabled then RefreshAll() end
    end
})

local SettingsTab = Window:Tab({Title = "Settings", Icon = "settings", Locked = false})
local UISettingsSection = SettingsTab:Section({Title = "UI Settings", Box = true, Opened = true})

UISettingsSection:Keybind({
    Title = "UI Toggle Key",
    Desc = "Key to open/close the UI",
    Value = "P",
    Callback = function(v) Window:SetToggleKey(Enum.KeyCode[v]) end
})
